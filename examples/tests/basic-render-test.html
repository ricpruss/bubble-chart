<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Basic Rendering Test</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="../../dist/bubble-chart.min.js"></script>
  <style>
    body { font-family: monospace; margin: 20px; }
    .debug { background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 4px; }
    .trace { background: #fff2e7; }
    .critical { background: #ffe7e7; border: 2px solid red; }
    .timing { background: #e7f5ff; }
    #chart { width: 600px; height: 400px; border: 1px solid #ddd; margin: 10px 0; }
    .timestamp { color: #666; font-size: 0.8em; }
  </style>
</head>
<body>

  <h1>🧪 Basic Rendering Test</h1>
  <div class="debug trace">
    <h3>Console Output:</h3>
    <div id="trace"></div>
  </div>
  <div id="chart"></div>

  <script>
    const logs = [];
    const startTime = performance.now();
    
    function getTimestamp() {
      return `[${(performance.now() - startTime).toFixed(1)}ms]`;
    }
    
    function log(message) {
      const timestampedMessage = `${getTimestamp()} ${message}`;
      logs.push(timestampedMessage);
      console.log(timestampedMessage);
    }

    // Auto-run test
    (async function runBasicRenderTest() {
      try {
        const testData = [
          { name: 'JavaScript', value: 95, category: 'language' },
          { name: 'Python', value: 88, category: 'language' },
          { name: 'TypeScript', value: 82, category: 'language' },
          { name: 'React', value: 90, category: 'framework' },
          { name: 'Vue', value: 75, category: 'framework' }
        ];

        log('=== BASIC RENDERING TEST START ===');
        log(`Test data: ${testData.length} items`);

        log('Step 1: Creating BubbleChart with D3-native fluent interface');
        // 🚀 D3-Native: Chart renders automatically when data is bound!
        const chart = BubbleChart.create('#chart')
          .withLabel('name')
          .withSize('value')
          .withDimensions(600, 400)
          .withColor(d3.scaleOrdinal(d3.schemeCategory10))
          .withData(testData)    // ✨ Auto-renders here!
          .build();              // Returns live chart (already rendered)

        log('Step 2: Chart created and rendered');
        // Access chart options through the builder instance
        const builder = chart.getBuilder();
        log(`Chart options: ${JSON.stringify(builder.options(), null, 2)}`);

        // Wait for rendering to complete
        await new Promise(resolve => setTimeout(resolve, 1000));

        log('Step 3: Verifying DOM elements');
        const svg = document.querySelector('#chart svg');
        const circles = document.querySelectorAll('#chart circle');
        
        if (!svg) {
          throw new Error('No SVG element found');
        }
        
        log(`SVG dimensions: ${svg.getAttribute('width')}x${svg.getAttribute('height')}`);
        log(`Circles rendered: ${circles.length} (expected: ${testData.length})`);

        if (circles.length !== testData.length) {
          throw new Error(`Expected ${testData.length} circles, got ${circles.length}`);
        }

        // Verify each bubble
        circles.forEach((circle, i) => {
          const r = circle.getAttribute('r');
          const cx = circle.getAttribute('cx');
          const cy = circle.getAttribute('cy');
          const fill = circle.getAttribute('fill');
          const opacity = getComputedStyle(circle).opacity;
          
          log(`Bubble ${i} (${testData[i].name}): r=${r}, pos=(${cx},${cy}), fill=${fill}, opacity=${opacity}`);
          
          if (!r || r <= 0) {
            throw new Error(`Bubble ${i} has invalid radius: ${r}`);
          }
        });

        log('Step 4: Checking text labels');
        const labels = document.querySelectorAll('#chart text');
        log(`Text labels: ${labels.length} found`);
        
        labels.forEach((label, i) => {
          const text = label.textContent;
          const x = label.getAttribute('x');
          const y = label.getAttribute('y');
          log(`Label ${i}: "${text}" at (${x},${y})`);
        });

        log('=== TEST RESULT: ✅ PASS ===');
        log(`Total execution time: ${(performance.now() - startTime).toFixed(1)}ms`);

      } catch (error) {
        log('=== TEST RESULT: ❌ FAIL ===');
        log(`Error: ${error.message}`);
        log(`Stack: ${error.stack}`);
      } finally {
        // Display logs in HTML
        const formattedLogs = logs.map(logLine => {
          if (logLine.includes('ms]')) {
            const parts = logLine.split('] ');
            return `<span class="timestamp">${parts[0]}]</span> ${parts[1]}`;
          }
          return logLine;
        });
        
        document.getElementById('trace').innerHTML = '<pre>' + formattedLogs.join('\n') + '</pre>';
      }
    })();
  </script>

</body>
</html>
