<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phase 2B Demo - Enhanced Reactive Binding & Error Handling</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="../../dist/bubble-chart.min.js"></script>
  <link rel="stylesheet" href="../../src/css/bubble-chart.css">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    }

    h1 {
      color: #4a5568;
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5em;
      font-weight: 300;
    }

    .subtitle {
      text-align: center;
      color: #718096;
      margin-bottom: 40px;
      font-size: 1.2em;
    }

    .demo-section {
      margin-bottom: 50px;
      background: white;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
    }

    .demo-section h2 {
      color: #2d3748;
      border-bottom: 3px solid #4299e1;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }

    .demo-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .chart-container {
      background: #f7fafc;
      border-radius: 10px;
      padding: 20px;
      border: 2px solid #e2e8f0;
      min-height: 400px;
    }

    .controls {
      background: #edf2f7;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .controls h3 {
      margin-top: 0;
      color: #2d3748;
    }

    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }

    button {
      background: linear-gradient(135deg, #4299e1, #3182ce);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
      min-width: 120px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(66, 153, 225, 0.3);
    }

    button:disabled {
      background: #a0aec0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .error-button {
      background: linear-gradient(135deg, #f56565, #e53e3e);
    }

    .success-button {
      background: linear-gradient(135deg, #48bb78, #38a169);
    }

    .status-panel {
      background: #f7fafc;
      border-radius: 10px;
      padding: 15px;
      margin-top: 15px;
      border-left: 4px solid #4299e1;
    }

    .status-panel h4 {
      margin: 0 0 10px 0;
      color: #2d3748;
    }

    .log-entry {
      background: #1a202c;
      color: #e2e8f0;
      padding: 8px 12px;
      border-radius: 5px;
      margin-bottom: 5px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      border-left: 3px solid #4299e1;
    }

    .log-entry.error {
      border-left-color: #f56565;
      background: #2d1b1b;
    }

    .log-entry.success {
      border-left-color: #48bb78;
      background: #1a2e1a;
    }

    .log-entry.warning {
      border-left-color: #ed8936;
      background: #2d2315;
    }

    .feature-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }

    .feature-card {
      background: white;
      border-radius: 10px;
      padding: 20px;
      border-left: 5px solid #4299e1;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    }

    .feature-card h4 {
      margin: 0 0 10px 0;
      color: #2d3748;
    }

    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }

    .metric {
      background: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      border-top: 3px solid #4299e1;
    }

    .metric-value {
      font-size: 2em;
      font-weight: bold;
      color: #2d3748;
    }

    .metric-label {
      color: #718096;
      font-size: 0.9em;
    }

    .code-sample {
      background: #1a202c;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 10px;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
      overflow-x: auto;
      border-left: 4px solid #4299e1;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üöÄ Phase 2B Demo</h1>
    <p class="subtitle">Enhanced Reactive Binding & Error Handling</p>

    <!-- Features Overview -->
    <div class="demo-section">
      <h2>‚ú® Phase 2B Features</h2>
      <div class="feature-list">
        <div class="feature-card">
          <h4>üîó Enhanced bindTo API</h4>
          <p>Supports promises, async functions, arrays, and observables with automatic retry and fallback mechanisms.</p>
        </div>
        <div class="feature-card">
          <h4>‚ö° Smart Error Handling</h4>
          <p>Comprehensive error events, reconnection logic, and data quality warnings with configurable retry policies.</p>
        </div>
        <div class="feature-card">
          <h4>üõ°Ô∏è Resilient Data Sources</h4>
          <p>WebSocket reconnection, HTTP retry with exponential backoff, and multiple fallback data sources.</p>
        </div>
        <div class="feature-card">
          <h4>üìä Real-time Monitoring</h4>
          <p>Live status updates, error tracking, and performance metrics for complete observability.</p>
        </div>
      </div>
    </div>

    <!-- Demo 1: Promise Binding with Retry -->
    <div class="demo-section">
      <h2>üîÑ Promise Binding with Automatic Retry</h2>
      <div class="demo-grid">
        <div class="chart-container" id="promise-chart"></div>
        <div>
          <div class="controls">
            <h3>Promise Data Sources</h3>
            <div class="button-group">
              <button id="bind-promise-success">‚úÖ Bind Success Promise</button>
              <button id="bind-promise-fail" class="error-button">‚ùå Bind Failing Promise</button>
              <button id="bind-promise-retry">üîÑ Bind with Retry</button>
              <button id="bind-fetch">üåê Bind Fetch Request</button>
            </div>
          </div>
          <div class="status-panel">
            <h4>üìà Metrics</h4>
            <div class="metrics">
              <div class="metric">
                <div class="metric-value" id="promise-attempts">0</div>
                <div class="metric-label">Retry Attempts</div>
              </div>
              <div class="metric">
                <div class="metric-value" id="promise-errors">0</div>
                <div class="metric-label">Total Errors</div>
              </div>
            </div>
          </div>
          <div class="status-panel">
            <h4>üìã Event Log</h4>
            <div id="promise-log" style="max-height: 200px; overflow-y: auto;"></div>
          </div>
        </div>
      </div>

      <div class="code-sample">
// Enhanced bindTo API with promises
chart.bindTo(fetch('/api/data').then(r => r.json()));

// Automatic retry for failed promises
chart.bindToWithRetry(
  () => fetch('/api/unreliable').then(r => r.json()),
  { maxRetries: 3, retryDelay: 1000 }
);

// Multiple fallback sources
chart.bindToWithFallback([
  () => fetch('/api/primary').then(r => r.json()),
  () => fetch('/api/backup').then(r => r.json()),
  () => Promise.resolve(fallbackData)
]);
      </div>
    </div>

    <!-- Demo 2: Error Handling & Events -->
    <div class="demo-section">
      <h2>üö® Error Handling & Event System</h2>
      <div class="demo-grid">
        <div class="chart-container" id="error-chart"></div>
        <div>
          <div class="controls">
            <h3>Error Simulation</h3>
            <div class="button-group">
              <button id="trigger-network-error" class="error-button">üåê Network Error</button>
              <button id="trigger-parse-error" class="error-button">üìä Parse Error</button>
              <button id="trigger-data-quality" class="error-button">‚ö†Ô∏è Data Quality Issue</button>
              <button id="simulate-recovery" class="success-button">üîß Simulate Recovery</button>
            </div>
          </div>
          <div class="status-panel">
            <h4>üè• System Health</h4>
            <div class="metrics">
              <div class="metric">
                <div class="metric-value" id="error-status">üü¢</div>
                <div class="metric-label">Connection Status</div>
              </div>
              <div class="metric">
                <div class="metric-value" id="error-count">0</div>
                <div class="metric-label">Error Count</div>
              </div>
            </div>
          </div>
          <div class="status-panel">
            <h4>üìã Error Events</h4>
            <div id="error-log" style="max-height: 200px; overflow-y: auto;"></div>
          </div>
        </div>
      </div>

      <div class="code-sample">
// Error event handling
chart.onStream('stream:error', (payload) => {
  console.log('Stream error:', payload.error);
  showErrorNotification(payload.error.message);
});

chart.onStream('stream:reconnected', () => {
  console.log('Connection restored!');
  showSuccessNotification('Reconnected successfully');
});

chart.onStream('data:quality-warning', (payload) => {
  console.warn('Data quality issues:', payload.issues);
  showDataQualityWarning(payload.issues);
});
      </div>
    </div>

    <!-- Demo 3: Data Source Factory -->
    <div class="demo-section">
      <h2>üè≠ Enhanced Data Source Factory</h2>
      <div class="demo-grid">
        <div class="chart-container" id="factory-chart"></div>
        <div>
          <div class="controls">
            <h3>Factory Methods</h3>
            <div class="button-group">
              <button id="factory-websocket">üîå WebSocket Source</button>
              <button id="factory-polling">üîÑ Polling Source</button>
              <button id="factory-auto-detect">ü§ñ Auto-detect</button>
              <button id="factory-load-balanced">‚öñÔ∏è Load Balanced</button>
            </div>
          </div>
          <div class="status-panel">
            <h4>‚öôÔ∏è Factory Configuration</h4>
            <div class="metrics">
              <div class="metric">
                <div class="metric-value" id="factory-sources">0</div>
                <div class="metric-label">Active Sources</div>
              </div>
              <div class="metric">
                <div class="metric-value" id="factory-retries">3</div>
                <div class="metric-label">Max Retries</div>
              </div>
            </div>
          </div>
          <div class="status-panel">
            <h4>üìã Factory Events</h4>
            <div id="factory-log" style="max-height: 200px; overflow-y: auto;"></div>
          </div>
        </div>
      </div>

      <div class="code-sample">
// Enhanced DataSourceFactory with resilience
DataSourceFactory.configure({
  errorRecovery: { maxRetries: 5, retryDelay: 2000 },
  healthCheck: true,
  healthCheckInterval: 30000
});

// Auto-retry WebSocket with health monitoring
const source = DataSourceFactory.fromWebSocket('ws://api.com/data', {
  autoReconnect: true,
  maxReconnectAttempts: 5,
  heartbeat: true
});

// Load-balanced sources with fallback
const balancedSource = DataSourceFactory.createLoadBalanced([
  { websocket: { url: 'ws://primary.api.com' } },
  { polling: { url: 'http://backup.api.com', interval: 5000 } },
  { static: { data: fallbackData } }
]);
      </div>
    </div>

    <!-- Performance Metrics -->
    <div class="demo-section">
      <h2>üìä Performance & Reliability Metrics</h2>
      <div class="metrics">
        <div class="metric">
          <div class="metric-value" id="total-requests">0</div>
          <div class="metric-label">Total Requests</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="success-rate">100%</div>
          <div class="metric-label">Success Rate</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="avg-response-time">0ms</div>
          <div class="metric-label">Avg Response Time</div>
        </div>
        <div class="metric">
          <div class="metric-value" id="reconnection-time">0s</div>
          <div class="metric-label">Last Reconnection</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Demo data and utilities
    const sampleData = [
      { name: 'Apple', value: 100, category: 'Tech', revenue: 365.8 },
      { name: 'Microsoft', value: 85, category: 'Tech', revenue: 198.3 },
      { name: 'Amazon', value: 75, category: 'Tech', revenue: 469.8 },
      { name: 'Google', value: 70, category: 'Tech', revenue: 282.8 },
      { name: 'Meta', value: 60, category: 'Tech', revenue: 117.9 }
    ];

    let promiseAttempts = 0;
    let promiseErrors = 0;
    let errorCount = 0;
    let totalRequests = 0;
    let responseTimes = [];

    // Utility functions
    function log(containerId, message, type = 'info') {
      const container = document.getElementById(containerId);
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      container.insertBefore(entry, container.firstChild);
      
      // Keep only last 10 entries
      while (container.children.length > 10) {
        container.removeChild(container.lastChild);
      }
    }

    function updateMetric(id, value) {
      document.getElementById(id).textContent = value;
    }

    function simulateNetworkDelay(min = 200, max = 800) {
      return new Promise(resolve => {
        const delay = Math.random() * (max - min) + min;
        log('promise-log', `Simulating network delay: ${Math.round(delay)}ms`, 'info');
        setTimeout(resolve, delay);
      });
    }

    function createPromiseDataSource(shouldFail = false, retryCount = 0) {
      return new Promise(async (resolve, reject) => {
        totalRequests++;
        updateMetric('total-requests', totalRequests);
        
        const startTime = Date.now();
        
        try {
          await simulateNetworkDelay();
          
          if (shouldFail && Math.random() < 0.7) { // 70% failure rate
            throw new Error(`Simulated network failure (attempt ${retryCount + 1})`);
          }
          
          const responseTime = Date.now() - startTime;
          responseTimes.push(responseTime);
          const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
          updateMetric('avg-response-time', Math.round(avgResponseTime) + 'ms');
          
          // Create visually distinct data to show the binding worked
          const newData = sampleData.map((item, index) => ({
            ...item,
            name: `${item.name}‚≠ê`, // Add star to show it's updated data
            value: item.value * (1.5 + Math.random() * 0.5) // Significantly larger values
          }));
          
          log('promise-log', `Promise resolving with updated data (${newData.length} items)...`, 'info');
          resolve(newData);
        } catch (error) {
          promiseErrors++;
          errorCount++;
          updateMetric('promise-errors', promiseErrors);
          updateMetric('error-count', errorCount);
          reject(error);
        }
      });
    }

    // Initialize reactive charts with enhanced bindTo functionality
    // Use the ReactiveBubbleBuilder to get charts with enhanced binding methods
    const promiseChart = new BubbleChart.ReactiveBubbleBuilder({
      container: '#promise-chart',
      label: 'name',
      size: 'value'
    })
      .data(sampleData)
      .enableStreaming()
      .render();

    const errorChart = new BubbleChart.ReactiveBubbleBuilder({
      container: '#error-chart',
      label: 'name', 
      size: 'value'
    })
      .data(sampleData)
      .enableStreaming()
      .render();

    const factoryChart = new BubbleChart.ReactiveBubbleBuilder({
      container: '#factory-chart',
      label: 'name',
      size: 'value'
    })
      .data(sampleData)
      .enableStreaming()
      .render();

    // Set up error event handling for all charts
    [promiseChart, errorChart, factoryChart].forEach(chart => {
      if (chart.onStream) {
        chart.onStream('stream:error', (payload) => {
          if (chart === promiseChart) {
            log('promise-log', `‚ùå Promise failed: ${payload.error.message}`, 'error');
            log('promise-log', `Error type: ${payload.error.type}, retryable: ${payload.error.retryable}`, 'warning');
          } else {
            log('error-log', `Error: ${payload.error.message}`, 'error');
          }
          updateMetric('error-status', 'üî¥');
        });

        chart.onStream('stream:reconnected', () => {
          log('error-log', 'Connection restored!', 'success');
          updateMetric('error-status', 'üü¢');
        });

        chart.onStream('data:quality-warning', (payload) => {
          log('error-log', `Data quality warning: ${payload.issues.join(', ')}`, 'warning');
        });

        chart.onStream('data:update', (data) => {
          // Only log non-empty data updates to avoid noise from initial empty states
          if (data && data.length > 0) {
            if (chart === promiseChart) {
              log('promise-log', `‚úÖ Promise resolved! Updated chart with ${data.length} items`, 'success');
              log('promise-log', `Sample values: ${data.slice(0, 3).map(d => d.name + '=' + Math.round(d.value)).join(', ')}`, 'info');
            } else if (chart === errorChart) {
              log('error-log', `Data updated: ${data.length} items`, 'success');
            } else {
              log('factory-log', `Data updated: ${data.length} items`, 'success');
            }
          }
        });
      }
    });

    // Promise demo event handlers
    document.getElementById('bind-promise-success').addEventListener('click', () => {
      log('promise-log', 'Binding to success promise...', 'info');
      log('promise-log', 'Creating promise data source...', 'info');
      
      if (promiseChart.bindTo) {
        try {
          promiseChart.bindTo(createPromiseDataSource(false));
          log('promise-log', 'Promise binding initiated successfully', 'info');
          log('promise-log', 'Waiting for promise to resolve...', 'info');
        } catch (error) {
          log('promise-log', `Binding failed: ${error.message}`, 'error');
        }
      } else {
        log('promise-log', 'Enhanced bindTo not available', 'error');
      }
    });

    document.getElementById('bind-promise-fail').addEventListener('click', () => {
      log('promise-log', 'Binding to failing promise (70% failure rate)...', 'info');
      
      if (promiseChart.bindTo) {
        try {
          promiseChart.bindTo(createPromiseDataSource(true));
          log('promise-log', 'Failing promise binding initiated', 'info');
          log('promise-log', 'This promise has a 70% chance to fail...', 'warning');
        } catch (error) {
          log('promise-log', `Binding failed: ${error.message}`, 'error');
        }
      } else {
        log('promise-log', 'Enhanced bindTo not available', 'error');
      }
    });

    document.getElementById('bind-promise-retry').addEventListener('click', () => {
      log('promise-log', 'Binding with automatic retry...', 'info');
      
      if (promiseChart.bindToWithRetry) {
        promiseChart.bindToWithRetry(
          () => createPromiseDataSource(true, promiseAttempts++),
          { maxRetries: 3, retryDelay: 1000 }
        );
        updateMetric('promise-attempts', promiseAttempts);
      } else {
        log('promise-log', 'Retry binding not available', 'error');
      }
    });

    document.getElementById('bind-fetch').addEventListener('click', () => {
      log('promise-log', 'Binding to fetch request...', 'info');
      
      if (promiseChart.bindToFetch) {
        // Mock a working API endpoint for demo purposes
        // Override fetch temporarily to simulate successful API response
        const originalFetch = window.fetch;
        let fetchCallCount = 0;
        
        window.fetch = async (url, options) => {
          fetchCallCount++;
          log('promise-log', `üì° Fetch attempt ${fetchCallCount} to ${url}`, 'info');
          
          // Simulate network delay
          await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 200));
          
          // 80% success rate for demo variety
          if (Math.random() < 0.8) {
            log('promise-log', `‚úÖ Mock API responded with success`, 'success');
            
            // Return mock successful response
            const mockData = sampleData.map(item => ({
              ...item,
              name: `${item.name}üåê`, // Globe icon to show it's from "API"
              value: item.value * (0.8 + Math.random() * 0.6) // Varied sizes
            }));
            
            return {
              ok: true,
              json: async () => mockData,
              status: 200,
              statusText: 'OK'
            };
          } else {
            log('promise-log', `‚ùå Mock API returned 500 error`, 'error');
            return {
              ok: false,
              status: 500,
              statusText: 'Internal Server Error'
            };
          }
        };
        
        // Restore original fetch after 10 seconds
        setTimeout(() => {
          window.fetch = originalFetch;
          log('promise-log', 'üîÑ Fetch interceptor removed', 'info');
        }, 10000);
        
        // Use the fetch binding with mock API
        promiseChart.bindToFetch('/api/mock-data', {
          maxRetries: 2,
          retryDelay: 1500
        });
        
        log('promise-log', 'üé≠ Using mock API responses for demo', 'info');
      } else {
        log('promise-log', 'Fetch binding not available', 'error');
      }
    });

    // Error demo event handlers
    document.getElementById('trigger-network-error').addEventListener('click', () => {
      log('error-log', 'Triggering network error...', 'error');
      errorCount++;
      updateMetric('error-count', errorCount);
      updateMetric('error-status', 'üî¥');
      
      // Simulate error event
      setTimeout(() => {
        log('error-log', 'Network timeout occurred', 'error');
      }, 1000);
    });

    document.getElementById('trigger-parse-error').addEventListener('click', () => {
      log('error-log', 'Triggering parse error...', 'error');
      errorCount++;
      updateMetric('error-count', errorCount);
      
      // Simulate invalid data
      setTimeout(() => {
        log('error-log', 'Invalid JSON response received', 'error');
      }, 500);
    });

    document.getElementById('trigger-data-quality').addEventListener('click', () => {
      log('error-log', 'Triggering data quality warning...', 'warning');
      
      // Simulate data quality issues
      const issues = ['Missing required field: revenue', '3 null values detected'];
      setTimeout(() => {
        log('error-log', `Data quality issues: ${issues.join(', ')}`, 'warning');
      }, 300);
    });

    document.getElementById('simulate-recovery').addEventListener('click', () => {
      log('error-log', 'Simulating recovery...', 'success');
      updateMetric('error-status', 'üü¢');
      updateMetric('reconnection-time', '2s');
      
      setTimeout(() => {
        log('error-log', 'Connection successfully restored', 'success');
      }, 2000);
    });

    // Factory demo event handlers
    document.getElementById('factory-websocket').addEventListener('click', () => {
      log('factory-log', 'Creating WebSocket data source...', 'info');
      updateMetric('factory-sources', 1);
      
      setTimeout(() => {
        log('factory-log', 'WebSocket source created with auto-reconnect', 'success');
      }, 1000);
    });

    document.getElementById('factory-polling').addEventListener('click', () => {
      log('factory-log', 'Creating polling data source...', 'info');
      updateMetric('factory-sources', 1);
      
      setTimeout(() => {
        log('factory-log', 'Polling source created with 5s interval', 'success');
      }, 800);
    });

    document.getElementById('factory-auto-detect').addEventListener('click', () => {
      log('factory-log', 'Auto-detecting data source type...', 'info');
      
      setTimeout(() => {
        log('factory-log', 'Auto-detected: HTTP polling source', 'success');
        updateMetric('factory-sources', 1);
      }, 1200);
    });

    document.getElementById('factory-load-balanced').addEventListener('click', () => {
      log('factory-log', 'Creating load-balanced sources...', 'info');
      
      setTimeout(() => {
        log('factory-log', 'Load balancer created with 3 sources', 'success');
        updateMetric('factory-sources', 3);
      }, 1500);
    });

    // Update success rate periodically
    setInterval(() => {
      if (totalRequests > 0) {
        const successRate = ((totalRequests - promiseErrors) / totalRequests * 100).toFixed(1);
        updateMetric('success-rate', successRate + '%');
      }
    }, 1000);

    // Initialize metrics
    updateMetric('total-requests', totalRequests);
    updateMetric('promise-attempts', promiseAttempts);
    updateMetric('promise-errors', promiseErrors);
    updateMetric('error-count', errorCount);
    updateMetric('factory-sources', 0);
    updateMetric('success-rate', '100%');
    updateMetric('avg-response-time', '0ms');
    updateMetric('reconnection-time', '0s');
    updateMetric('error-status', 'üü¢');

    console.log('Phase 2B Demo initialized successfully! üöÄ');
  </script>
</body>
</html> 