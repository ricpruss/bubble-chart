<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Event Handling Test</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="../../dist/bubble-chart.min.js"></script>
  <style>
    body { font-family: monospace; margin: 20px; }
    .debug { background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 4px; }
    .trace { background: #fff2e7; }
    .critical { background: #ffe7e7; border: 2px solid red; }
    .timing { background: #e7f5ff; }
    #chart { width: 600px; height: 400px; border: 1px solid #ddd; margin: 10px 0; }
    .timestamp { color: #666; font-size: 0.8em; }
    .instructions { background: #e7f3ff; padding: 10px; margin: 10px 0; border-radius: 4px; }
  </style>
</head>
<body>

  <h1>üéØ Event Handling Test</h1>
  <div class="instructions">
    <strong>Instructions:</strong> This test will automatically set up event handlers. 
    Try clicking and hovering over the bubbles to test events!
  </div>
  <div class="debug trace">
    <h3>Console Output:</h3>
    <div id="trace"></div>
  </div>
  <div id="chart"></div>

  <script>
    const logs = [];
    const eventLogs = [];
    const startTime = performance.now();
    
    function getTimestamp() {
      return `[${(performance.now() - startTime).toFixed(1)}ms]`;
    }
    
    function log(message) {
      const timestampedMessage = `${getTimestamp()} ${message}`;
      logs.push(timestampedMessage);
      console.log(timestampedMessage);
    }

    function logEvent(message) {
      const timestampedMessage = `${getTimestamp()} EVENT: ${message}`;
      eventLogs.push(timestampedMessage);
      logs.push(timestampedMessage);
      console.log(timestampedMessage);
      updateDisplay();
    }

    function updateDisplay() {
      const formattedLogs = logs.map(logLine => {
        if (logLine.includes('ms]')) {
          const parts = logLine.split('] ');
          return `<span class="timestamp">${parts[0]}]</span> ${parts[1]}`;
        }
        return logLine;
      });
      
      document.getElementById('trace').innerHTML = '<pre>' + formattedLogs.join('\n') + '</pre>';
    }

    // Auto-run test
    (async function runEventHandlingTest() {
      try {
        const testData = [
          { name: 'JavaScript', value: 95, category: 'language' },
          { name: 'Python', value: 88, category: 'language' },
          { name: 'TypeScript', value: 82, category: 'language' },
          { name: 'React', value: 90, category: 'framework' },
          { name: 'Vue', value: 75, category: 'framework' }
        ];

        log('=== EVENT HANDLING TEST START ===');
        log(`Test data: ${testData.length} items`);

        log('Step 1: Creating chart with D3-native API');
        // üöÄ D3-Native: Chart renders automatically when data is bound!
        const chart = BubbleChart.create('#chart')
          .withLabel('name')
          .withSize('value')
          .withDimensions(600, 400)
          .withColor(d3.scaleOrdinal(d3.schemeTableau10))
          .withData(testData)    // ‚ú® Auto-renders here!
          .build();              // Returns live chart (already rendered)

        log('Step 2: Setting up event handlers');
        
        // Track event handler setup
        let clickHandlerSet = false;
        let mouseoverHandlerSet = false;
        let mouseoutHandlerSet = false;

        try {
          chart.onBubble('click', (data, event, element) => {
            logEvent(`Click on "${data.name}" (value: ${data.value})`);
            logEvent(`Click position: (${event.clientX}, ${event.clientY})`);
            logEvent(`Element: ${element.tagName}, radius: ${element.getAttribute('r')}`);
          });
          clickHandlerSet = true;
          log('‚úì Click handler attached');
        } catch (error) {
          log(`‚úó Click handler failed: ${error.message}`);
        }

        try {
          chart.onBubble('mouseover', (data, event, element) => {
            logEvent(`Hover start on "${data.name}"`);
            // Change bubble opacity for visual feedback
            element.style.opacity = '0.7';
          });
          mouseoverHandlerSet = true;
          log('‚úì Mouseover handler attached');
        } catch (error) {
          log(`‚úó Mouseover handler failed: ${error.message}`);
        }

        try {
          chart.onBubble('mouseout', (data, event, element) => {
            logEvent(`Hover end on "${data.name}"`);
            // Restore bubble opacity
            element.style.opacity = '1.0';
          });
          mouseoutHandlerSet = true;
          log('‚úì Mouseout handler attached');
        } catch (error) {
          log(`‚úó Mouseout handler failed: ${error.message}`);
        }

        // Wait for rendering to complete
        await new Promise(resolve => setTimeout(resolve, 1000));

        log('Step 3: Verifying chart render');
        const circles = document.querySelectorAll('#chart circle');
        log(`Rendered circles: ${circles.length} (expected: ${testData.length})`);
        
        if (circles.length !== testData.length) {
          throw new Error(`Render failed: expected ${testData.length}, got ${circles.length}`);
        }

        log('Step 4: Programmatically triggering events for testing');
        
        // Simulate click on first bubble
        if (circles.length > 0 && clickHandlerSet) {
          const firstBubble = circles[0];
          const clickEvent = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            clientX: 100,
            clientY: 100
          });
          
          log('Simulating click on first bubble...');
          firstBubble.dispatchEvent(clickEvent);
        }

        // Simulate mouseover/mouseout on second bubble
        if (circles.length > 1 && mouseoverHandlerSet && mouseoutHandlerSet) {
          const secondBubble = circles[1];
          
          log('Simulating mouseover on second bubble...');
          const mouseoverEvent = new MouseEvent('mouseover', {
            bubbles: true,
            cancelable: true
          });
          secondBubble.dispatchEvent(mouseoverEvent);

          await new Promise(resolve => setTimeout(resolve, 500));

          log('Simulating mouseout on second bubble...');
          const mouseoutEvent = new MouseEvent('mouseout', {
            bubbles: true,
            cancelable: true
          });
          secondBubble.dispatchEvent(mouseoutEvent);
        }

        await new Promise(resolve => setTimeout(resolve, 500));

        log('Step 5: Event handler verification');
        const successfulHandlers = [clickHandlerSet, mouseoverHandlerSet, mouseoutHandlerSet].filter(Boolean).length;
        log(`Event handlers set up: ${successfulHandlers}/3`);
        log(`Events captured: ${eventLogs.length}`);

        if (successfulHandlers === 3 && eventLogs.length >= 3) {
          log('=== TEST RESULT: ‚úÖ PASS ===');
          log('Event handling system working correctly');
          log('Try interacting with the bubbles above to see more events!');
        } else {
          log('=== TEST RESULT: ‚ö†Ô∏è PARTIAL ===');
          log('Some event handlers may not be working correctly');
        }

        log(`Total execution time: ${(performance.now() - startTime).toFixed(1)}ms`);

      } catch (error) {
        log('=== TEST RESULT: ‚ùå FAIL ===');
        log(`Error: ${error.message}`);
        log(`Stack: ${error.stack}`);
      } finally {
        updateDisplay();
      }
    })();
  </script>

</body>
</html>
