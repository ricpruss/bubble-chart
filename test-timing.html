<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Animation Timing Test</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="./dist/bubble-chart.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #chart { border: 1px solid #ccc; margin: 20px 0; }
    .info { background: #e7f3ff; padding: 10px; border-radius: 4px; margin: 10px 0; }
    button { margin: 5px; padding: 8px 16px; }
  </style>
</head>
<body>
  <h1>Animation Timing Coordination Test</h1>
  
  <div class="info">
    <strong>Expected Behavior:</strong> 
    <br>â€¢ Update animations should last long enough to prevent overlaps with staggered enter animations
    <br>â€¢ Console should show timing coordination debug messages
    <br>â€¢ No bubbles should overlap or stack during streaming updates
  </div>
  
  <div>
    <button onclick="addBubbles()">Add 5 Bubbles</button>
    <button onclick="shuffleSizes()">Shuffle Sizes (Trigger Updates)</button>
    <button onclick="clearChart()">Clear</button>
  </div>
  
  <div id="chart"></div>
  
  <div id="log" style="background: #f5f5f5; padding: 10px; border-radius: 4px; font-family: monospace; max-height: 200px; overflow-y: auto;">
    <strong>Console Log:</strong><br>
  </div>

  <script>
    let chart;
    let dataCounter = 0;
    let currentData = [];
    
    // Sample data generator
    function generateBubble() {
      return {
        id: `bubble-${++dataCounter}`,
        name: `Item ${dataCounter}`,
        size: Math.random() * 5000 + 1000,
        category: ['Tech', 'Health', 'Finance', 'Energy', 'Retail'][Math.floor(Math.random() * 5)]
      };
    }
    
    // Initialize chart with streaming enabled
    function initChart() {
      chart = BubbleChart.create('#chart')
        .withData([])
        .withSize('size')
        .withLabel('name')
        .withColor(d => getColor(d.category))
        .withDimensions(800, 500)
        .withAnimations({
          enter: { duration: 800, stagger: 50, easing: 'ease-out' },
          update: { duration: 600, easing: 'ease-in-out' },  // This should be auto-adjusted
          exit: { duration: 400, easing: 'ease-in' }
        });
        
      // Enable reactive features if available
      if (chart.store) {
        chart.render();
        log('Chart initialized with reactive streaming');
      } else {
        chart.render();
        log('Chart initialized (non-reactive)');
      }
    }
    
    function getColor(category) {
      const colors = {
        'Tech': '#3498db',
        'Health': '#e74c3c', 
        'Finance': '#2ecc71',
        'Energy': '#9b59b6',
        'Retail': '#f39c12'
      };
      return colors[category] || '#95a5a6';
    }
    
    function addBubbles() {
      if (!chart.store) {
        log('ERROR: Reactive store not available');
        return;
      }
      
      log(`Adding 5 new bubbles (current count: ${currentData.length})`);
      
      for (let i = 0; i < 5; i++) {
        const bubble = generateBubble();
        currentData.push(bubble);
        chart.store.add(bubble);
      }
      
      log(`Total bubbles: ${currentData.length}`);
    }
    
    function shuffleSizes() {
      if (!chart.store) {
        log('ERROR: Reactive store not available');
        return;
      }
      
      if (currentData.length === 0) {
        log('No bubbles to shuffle');
        return;
      }
      
      log(`Shuffling sizes for ${currentData.length} bubbles`);
      
      // Update all bubble sizes to trigger update animations
      const updatedData = currentData.map(bubble => ({
        ...bubble,
        size: Math.random() * 5000 + 1000
      }));
      
      currentData = updatedData;
      chart.store.replaceWith(updatedData);
      
      log('Size shuffle complete - watch for timing coordination');
    }
    
    function clearChart() {
      if (!chart.store) {
        log('ERROR: Reactive store not available');
        return;
      }
      
      log('Clearing all bubbles');
      chart.store.clear();
      currentData = [];
    }
    
    function log(message) {
      const logEl = document.getElementById('log');
      const timestamp = new Date().toLocaleTimeString();
      logEl.innerHTML += `<br>[${timestamp}] ${message}`;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(message);
    }
    
    // Override console.log to capture timing coordination messages
    const originalLog = console.log;
    console.log = function(...args) {
      const message = args.join(' ');
      if (message.includes('Animation Timing Coordination')) {
        log('ðŸŽ¬ ' + message);
      }
      originalLog.apply(console, args);
    };
    
    // Initialize when page loads
    window.addEventListener('load', initChart);
  </script>
</body>
</html>
